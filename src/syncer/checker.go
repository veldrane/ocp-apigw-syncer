// package generated by goa example command. Look at ./design directory for goa dsl files
// It contains 4 services
//
//	check - the main syncer enpoint for checking synchronization status
//	swagger - export swagger client
//	root - just a root redirect to the swagger
//	health - health check mainly for kubernetes purpose
package syncer

import (
	"context"
	"log"
	checker "syncer/gen/checker"
	"time"

	"crypto/tls"
	"net/http"

	l "github.com/synclib"
)

// checker service example implementation.
// The example methods log the requests and return zero values.
type checkersrvc struct {
	requestConfig *l.Config
	nginxs        *l.NginxInstancies
	logger        *log.Logger
	httpClient    http.Client
}

// NewChecker returns the checker service implementation.
// Function return basic logger interface, list of the nginx pods and structure
// describes global config
func NewChecker(requestConfig *l.Config, nginxs *l.NginxInstancies, logger *log.Logger) checker.Service {

	httpClient, err := initHttpClient(requestConfig)

	if err != nil {
		panic("Http client cannot be initialized")
	}

	return &checkersrvc{requestConfig, nginxs, logger, httpClient}
}

// Get last full report Main handler of the endpoint /v1/synced
// Endpoint return one of the four statuses: Synced, Partialy, NotSynced, Timeout
func (s *checkersrvc) Get(ctx context.Context, p *checker.GetPayload) (res *checker.Sync, err error) {

	if numPods := len(s.nginxs.Pods); numPods < 2 {
		s.logger.Printf("[ Get ] -> Not sync check required for token %s - nginx pods doesnt have replicas", p.AuthToken)
		return &checker.Sync{Status: "Synced"}, nil
	}

	cp := l.InitCheckPayload(p.AuthToken, p.Origin, &s.httpClient)

	ctxCheck, cancel := context.WithTimeout(ctx, time.Duration(s.requestConfig.Deadline*int(time.Millisecond)))
	defer cancel()

	status := s.nginxs.Check(s.requestConfig, cp, ctxCheck, s.logger)

	return &checker.Sync{Status: status}, nil
}

func initHttpClient(config *l.Config) (http.Client, error) {

	tr := http.Transport{
		TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
		MaxIdleConnsPerHost:   2,
		MaxIdleConns:          4,
		ResponseHeaderTimeout: (time.Duration(config.ConnTimeout) / 2) * time.Millisecond,
	}

	client := http.Client{
		Transport: &tr,
		Timeout:   time.Duration(config.ConnTimeout) * time.Millisecond,
	}

	return client, nil
}
